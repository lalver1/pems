{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"PeMS","text":"<p>Caltrans Performance Measurement System</p> <p>PeMS is open-source software that is designed, developed, and maintained by Compiler LLC on behalf of Caltrans Traffic Operations.</p>"},{"location":"#current-work","title":"Current Work","text":"<p>We do sprint planning and track day-to-day work in our Project Board.</p> <p>See our current Milestones for a higher level view of project progress.</p>"},{"location":"#product-roadmap","title":"Product Roadmap","text":"<p>Our product roadmap captures what we\u2019re currently building, what we\u2019ve built, and what we plan to build in future quarters. It is updated on a regular basis, aligned with project progress.</p> <pre><code>timeline\n    title PeMS Product Roadmap\n    %% PeMS Epics (2024)\n    section 2024\n\n    Q3&lt;br&gt;Complete\n    : Project launch\n    : Established resources and overall scope\n    : Began discovery work\n\n    Q4&lt;br&gt;Complete\n    : Confirm site architecture\n    : Set up GitHub repository\n    : Scaffold app structure\n    : Create a prioritized backlog of features\n    : Created local environment\n\n    %% PeMS Epics (2025)\n    section 2025\n\n    Q1&lt;br&gt;Complete\n    : Project paused for AWS license approval\n\n    Q2&lt;br&gt;Now\n    : Create dev environment\n    : Create test environment\n    : Launch test version of district-specific pages\n    : Set up a working CI/CD pipeline\n\n    Q3&lt;br&gt;Planned\n    : Create production environment\n    : User testing for district-specific pages and initial features (early Q3)\n    : Launch test version of full site\n    : Additional user testing for full site (timing TBD)\n\n    Q4&lt;br&gt;Future\n    : Go-Live - Date TBD\n    : Compiler contract for PeMS ends September 2025, but planning to extend to Dec. 2025\n\n    %%{\n        init: {\n            'logLevel': 'debug',\n            'theme': 'default' ,\n            'themeVariables': {\n                'cScale0': '#ffa500', 'cScaleLabel0': '#000000',\n                'cScale1': '#ffff00', 'cScaleLabel1': '#000000',\n                'cScale2': '#ffff00', 'cScaleLabel2': '#000000',\n                'cScale3': '#008000', 'cScaleLabel3': '#ffffff',\n                'cScale4': '#0000ff', 'cScaleLabel4': '#ffffff',\n                'cScale5': '#4b0082', 'cScaleLabel5': '#ffffff',\n                'cScale6': '#000000', 'cScaleLabel6': '#ffffff'\n            }\n        }\n    }%%</code></pre>"},{"location":"deployment/hotfix/","title":"Making a hotfix release","text":"<p>This list outlines the manual steps needed to make a hotfix release of the <code>pems</code> app.</p> <p>If <code>main</code> contains in-progress work that is not yet ready for a release but a simple code fix is needed in production, a separate process to test the changes before deploying to production must be undertaken. This is called a hotfix release. Typically, a hotfix release involves a simple code change that can be quickly implemented, in contrast to a rollback release, which generally requires more complex code changes which take more time to implement. To coordinate the work that\u2019s required for a hotfix release, a <code>Release process Issue</code> needs to be created. The button below will help you start a new <code>Release process Issue</code> by using an Issue template.</p> <p>Start a new Release on Github</p>"},{"location":"deployment/hotfix/#0-create-a-temporary-hotfix-branch-from-the-latest-release-tag","title":"0. Create a temporary hotfix branch from the latest release tag","text":"<pre><code>git checkout -b &lt;hotfix-branch&gt; &lt;release-tag&gt;\n</code></pre> <p>Replace <code>&lt;hotfix-branch&gt;</code> with the hotfix branch name and <code>&lt;release-tag&gt;</code> with the latest release tag.</p>"},{"location":"deployment/hotfix/#1-fix-whatever-issue-is-wrong-using-the-hotfix-branch","title":"1. Fix whatever issue is wrong using the hotfix branch","text":"<p>Commit the code changes that fix the issue that prompted the hotfix.</p>"},{"location":"deployment/hotfix/#2-tag-the-head-of-the-hotfix-branch-with-a-release-tag","title":"2. Tag the HEAD of the hotfix branch with a release tag","text":"<pre><code>git tag -a YYYY.0M.R\n</code></pre> <p>Git will open your default text editor and prompt you for the tag annotation. For the tag annotation, use the release tag version and close the text editor.</p>"},{"location":"deployment/hotfix/#3-push-the-tag-to-github-to-kick-off-the-hotfix","title":"3. Push the tag to GitHub to kick off the hotfix","text":"<pre><code>git push origin YYYY.0M.R\n</code></pre>"},{"location":"deployment/hotfix/#4-generate-release-notes","title":"4. Generate release notes","text":"<p>Edit release notes with additional context, images, animations, etc. as-needed and link to the <code>Release process Issue</code>.</p>"},{"location":"deployment/hotfix/#5-merge-into-main-for-the-next-release","title":"5. Merge into <code>main</code> for the next release","text":"<p>Create a PR to merge the changes from the hotfix branch into <code>main</code> for the next release.</p>"},{"location":"deployment/release/","title":"Making a release","text":"<p>This list outlines the manual steps needed to make a new release of the <code>pems</code> app.</p> <p>A release is made by pushing an annotated tag that is named after the version number for the app and the release. The name of the tag must use the version number format mentioned below. Pushing an annotated tag kicks off a deployment (implemented as a GitHub Actions workflow) that builds, tags, and pushes the app\u2019s image to the GitHub Container Registry and then creates a GitHub release. It is often useful to monitor the release process by looking at the status of the Deploy workflow under the <code>Actions</code> section of the repository.</p> <p>The list of releases can be found on the repository\u2019s Releases page on GitHub.</p>"},{"location":"deployment/release/#0-decide-on-the-new-version-number-and-create-a-release-process-issue","title":"0. Decide on the new version number and create a <code>Release process Issue</code>","text":"<p>A new release implies a new version.</p> <p><code>pems</code> uses the CalVer versioning scheme, where version numbers look like: <code>YYYY.0M.R</code></p> <ul> <li><code>YYYY</code> is the 4-digit year of the release; e.g. <code>2024</code>, <code>2025</code></li> <li><code>0M</code> is the 2-digit, 0-padded month of the release; e.g. <code>02</code> is February, <code>12</code>   is December.</li> <li><code>R</code> is the 1-based release counter for the given year and month;   e.g. <code>1</code> for the first release of the month, <code>2</code> for the second, and so on.</li> </ul> <p>Version numbers for release candidates append <code>-rcR</code>, where <code>R</code> is the 1-based release counter for the anticipated release. For example, the first release candidate for the <code>2025.01.1</code> release would be <code>2025.01.1-rc1</code>.</p> <p>To coordinate the work that\u2019s required for a release, a <code>Release process Issue</code> needs to be created. The button below will help you start a new <code>Release process Issue</code> by using an Issue template.</p> <p>Start a new Release on Github</p>"},{"location":"deployment/release/#1-create-a-release-candidate-tag-on-main-and-push-it","title":"1. Create a release candidate tag on <code>main</code> and push it","text":"<pre><code>git fetch\ngit checkout main\ngit reset --hard origin/main\ngit tag -a YYYY.0M.R-rcR\n</code></pre> <p>Git will open your default text editor and prompt you for the tag annotation. For the tag annotation, use <code>Release candidate R for YYYY.0M.R</code>. For example, <code>Release candidate 2 for 2025.01.1</code> would be the annotation for the second release candidate of the first release of January 2025. Finally, after closing the text editor:</p> <pre><code>git push origin YYYY.0M.R-rcR\n</code></pre> <p>This builds a new package, tags it, and pushes the app\u2019s image to GitHub Container Registry. No GitHub release is created for release candidates.</p>"},{"location":"deployment/release/#2-create-a-release-tag-on-main-and-push-it","title":"2. Create a release tag on <code>main</code> and push it","text":"<pre><code>git fetch\ngit checkout main\ngit reset --hard origin/main\ngit tag -a YYYY.0M.R\n</code></pre> <p>Git will open your default text editor and prompt you for the tag annotation. For the tag annotation, use the title of the Release process issue that kicked off the release. Finally, after closing the text editor:</p> <pre><code>git push origin YYYY.0M.R\n</code></pre> <p>This builds the package, tags it, pushes the app\u2019s image to GitHub Container Registry, and creates a GitHub release.</p>"},{"location":"deployment/release/#3-generate-release-notes","title":"3. Generate release notes","text":"<p>Edit release notes with additional context, images, animations, etc. as-needed and link to the <code>Release process Issue</code>.</p>"},{"location":"deployment/rollback/","title":"Making a rollback release","text":"<p>This list outlines the manual steps needed to make a rollback of the <code>pems</code> app.</p> <p>If a change is deployed to the app that makes it fail to start, making a rollback will deploy the app to a known working state again. To coordinate the work that\u2019s required for a rollback release, a <code>Release process Issue</code> needs to be created. The button below will help you start a new <code>Release process Issue</code> by using an Issue template.</p> <p>Start a new Release on Github</p>"},{"location":"deployment/rollback/#0-create-a-release-tag-on-the-commit-associated-with-the-last-known-good-release-tag","title":"0. Create a release tag on the commit associated with the last known good release tag","text":"<pre><code>git tag -a YYYY.0M.R &lt;commit-hash&gt;\n</code></pre> <p>Replace <code>YYYY.0M.R</code> with the rollback version and <code>&lt;commit-hash&gt;</code> with the hash of the commit associated with the last known good release tag. Git will open your default text editor and prompt you for the tag annotation. For the tag annotation, use the version of the release tag for the rollback and close the text editor.</p>"},{"location":"deployment/rollback/#1-push-the-tag-to-github-to-kick-off-the-rollback","title":"1. Push the tag to GitHub to kick off the rollback","text":"<pre><code>git push origin YYYY.0M.R\n</code></pre>"},{"location":"deployment/rollback/#2-generate-release-notes","title":"2. Generate release notes","text":"<p>Edit release notes with additional context, images, animations, etc. as-needed and link to the <code>Release process Issue</code>.</p>"},{"location":"development/","title":"Getting started with development","text":"<p>Info</p> <p>This guide will take you through the process of getting the <code>pems</code> project running in your local development environment.</p> <p><code>pems</code> uses VS Code devcontainers to provide a platform-agnostic, standardized development environment.</p> <p>For more about why we use Dev Containers, check our Compiler\u2019s blog post: How to support a platform-agnostic engineering team with VS Code Dev Containers.</p>"},{"location":"development/#prerequisites","title":"Prerequisites","text":"<p>This section describes the tooling you need to have installed and configured on your development machine before continuing.</p>"},{"location":"development/#git","title":"Git","text":"<p>Git is an open source version control system that we use in <code>pems</code> to track changes to the codebase over time. Many operating systems come with Git already installed. Check if you have Git installed in a terminal with the following command:</p> <pre><code>git --version\n</code></pre> <p>If git is installed, the output should look similar to:</p> <pre><code>$ git --version\ngit version 2.39.5\n</code></pre> <p>If Git is not installed, head to the Git downloads page to get an installer for your operating system.</p>"},{"location":"development/#docker-and-docker-compose","title":"Docker and Docker Compose","text":"<p>Docker and Docker Compose (or just Compose) are key tools that allow for running the various services required for <code>pems</code>.</p> <p>Confirm if you already have Docker installed, in a terminal:</p> <pre><code>docker --version\n</code></pre> <p>If Docker is installed, the output should look similar to:</p> <pre><code>$ docker --version\nDocker version 27.4.0, build bde2b89\n</code></pre> <p>And similarly to check if Compose is installed:</p> <pre><code>docker compose version\n</code></pre> <p>When Compose is installed, output will look similar to:</p> <pre><code>$ docker compose version\nDocker Compose version v2.31.0\n</code></pre> <p>There are different ways to acquire this software depending on your operating system. The simplest approach for Windows and MacOS users is to install Docker Desktop.</p> License requirements for Docker Desktop <p>Use of Docker Desktop is subject to Docker\u2019s licensing terms. In particular, note that Section 4.2 calls out government users specifically:</p> <p>Government Entities shall not use Docker Desktop or access other Entitlements of the Service without purchasing a Subscription.</p>"},{"location":"development/#windows","title":"Windows","text":"<p>It is possible to run Docker and Compose on Windows without installing Docker Desktop. This involves using the Windows Subsystem for Linux v2 (WSL2), where Docker is configured to run.</p> <p>This article walks through this procedure in more detail: How to run docker on Windows without Docker Desktop.</p>"},{"location":"development/#macos","title":"MacOS","text":"<p>With MacOS and Homebrew, installing Docker and Compose are as simple as:</p> <pre><code>brew install docker docker-compose colima\n</code></pre> <p>Once the install completes, start <code>colima</code> (an open source container runtime):</p> <pre><code>brew services start colima\n</code></pre>"},{"location":"development/#linux","title":"Linux","text":"<p>Docker CE (also known as Docker Engine) is how to run Docker and Compose on Linux. Docker provides an installation guide for Docker CE.</p>"},{"location":"development/#vs-code-and-dev-containers-extension","title":"VS Code and Dev Containers extension","text":"<p>VS Code is an open source Integrated Development Environment (IDE) from Microsoft. Check if you already have it installed:</p> <pre><code>code -v\n</code></pre> <p>If installed, output should look similar to:</p> <pre><code>$ code -v\n1.95.3\nf1a4fb101478ce6ec82fe9627c43efbf9e98c813\nx64\n</code></pre> <p>Otherwise, download VS Code for your operating system.</p> <p>Once installed, open VS Code and enter <code>Ctrl</code>/<code>Cmd</code> + <code>P</code> to open the VS Code Quick Open pane. Then enter:</p> <pre><code>ext install ms-vscode-remote.remote-containers\n</code></pre> <p><code>ms-vscode-remote.remote-containers</code> is the Extension ID of the Dev Containers extension from Microsoft.</p>"},{"location":"development/#get-the-project-code","title":"Get the project code","text":"<p>Use Git to clone the repository to your local machine:</p> <pre><code>git clone https://github.com/compilerla/pems.git\n</code></pre> <p>Then change into the <code>pems</code> directory and create an environment file from the sample:</p> <pre><code>cd pems\ncp .env.sample .env\n</code></pre> <p>Feel free to inspect the environment file, but leave the defaults for now.</p>"},{"location":"development/#run-the-application","title":"Run the application","text":"<p>Start the application service with Compose:</p> <pre><code>docker compose up -d web\n</code></pre> <p>The <code>-d</code> flag starts the service in \u201cdetatched\u201d mode, so your terminal is still available for additional commands. Without this flag, your terminal attaches to the service container\u2019s standard output.</p> <p>The application is now running on <code>http://localhost:8000</code>.</p> <p>Stop the running service with Compose:</p> <pre><code>docker compose down\n</code></pre>"},{"location":"development/#open-the-project-in-a-vs-code-devcontainer","title":"Open the project in a VS Code devcontainer","text":"<p>Still in your terminal, enter the following command to open the project in VS Code:</p> <pre><code>code .\n</code></pre> <p>Once the project is loaded in VS Code, you should see a notification pop-up that will ask if you want to reopen the project in a devcontainer.</p> <p>If you don\u2019t see this notification, or if you dismissed it, use the VS Code Quick Open pane with <code>Ctrl</code>/<code>Cmd</code> + <code>P</code> and enter:</p> <pre><code>&gt; Dev Containers: Rebuild and Reopen in Container\n</code></pre> <p>The VS Code window will reload into the devcontainer.</p> <p>Once loaded, hit <code>F5</code> to start the application in debug mode. The application is now running on <code>http://localhost:8000</code>.</p>"},{"location":"development/#explore-the-devcontainer","title":"Explore the devcontainer","text":"<p>This section describes other areas to explore within the VS Code devcontainer.</p>"},{"location":"development/#debugger","title":"Debugger","text":"<p>Open a Python file in the <code>pems/</code> directory and add a breakpoint by clicking the space next to a line number, leaving a small red circle where you clicked.</p> <p>Step through the running application on <code>http://localhost:8000</code> to trigger the code path you selected. Execution is paused and VS Code allows you to inspect the runtime environment, context, etc.</p>"},{"location":"development/#integrated-terminal","title":"Integrated terminal","text":"<p>Press <code>Ctrl</code> + <code>~</code> to bring up the integrated <code>TERMINAL</code> window. You are now in a <code>bash</code> terminal running inside the context of the devcontainer.</p>"},{"location":"development/#docs-site","title":"Docs site","text":"<p>Open the <code>PORTS</code> tab to see port bindings for additional services. Look for the <code>Forwarded Address</code> of the <code>docs</code> service and click to open the docs site in your browser, running on <code>localhost</code>.</p> <p>Edit the documentation files in VS Code, and once saved, the local docs site will rebuild with the changes.</p>"},{"location":"development/#test-runner","title":"Test runner","text":"<p>Use the VS Code Quick Open pane with <code>Ctrl</code>/<code>Cmd</code> + <code>P</code> and enter:</p> <pre><code>&gt; Testing: Focus\n</code></pre> <p>To focus on the <code>Testing</code> pane on the left side. Click the play button to run the unit tests.</p>"},{"location":"development/#work-with-the-cloud-infrastructure","title":"Work with the Cloud infrastructure","text":"<p>You can work on the app\u2019s Cloud infrastructure in the dev container by using the <code>aws</code> and <code>copilot</code> AWS CLIs. Successfully running the commands requires the container\u2019s host to be configured for authentication with IAM Identity Center by running <code>aws configure sso</code> and going through the setup. You can use the following settings:</p> <ul> <li><code>SSO session name (Recommended): pems</code></li> <li><code>SSO start URL [None]: url_provided_by_caltrans</code></li> <li><code>SSO region [None]: us-west-2</code></li> <li><code>SSO registration scopes [None]:</code></li> <li><code>Default client Region [None]: us-west-2</code></li> <li><code>CLI default output format (json if not specified) [None]:</code></li> <li><code>Profile name [123456789011_ReadOnly]: pems</code></li> </ul> <p>An active SSO session must be available to run the AWS commands, if it is not, run <code>aws sso login</code> inside the container to start a session.</p> <p>Running thes commands in the dev container is made possible by the mapping defined in the compose file that maps the host\u2019s AWS credentials folder to the dev container at <code>/home/caltrans/.aws</code>. For convenience, you can also set the default AWS profile that will be used in the dev container to <code>pems</code> as shown in <code>.env.sample</code>.</p>"},{"location":"development/#useful-commands","title":"Useful commands","text":"<p>Deploying</p> <ul> <li><code>copilot svc deploy -n service-name</code> to deploy a service (local code and configuration) that has already been initialized</li> </ul> <p>Monitoring</p> <ul> <li><code>copilot svc show -n service-name</code> to see the environment variables and other information associated with a service</li> <li><code>copilot svc logs -n service-name --since 1h</code> to see the logs for the past hour of a deployed service</li> <li><code>copilot svc exec -a app-name -e environment-name -n service-name</code> to gain shell access to a running container</li> </ul>"}]}